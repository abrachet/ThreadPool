# Thread pool implementation in C

Uses low level C features like atomics and thread_local as well as low level routines like longjmp and takes use of signals. Use of these, particularly signals make this thread pool able to give users large control with low overhead for that control. Killing a job for example can be done without killing the thread it is running on. Making this thread pool versitile and powerful. Ultimately there are less features than I would like, but it is built on a solid base that adding feautres is not difficult. 

### Problems and Future direction
Currently there is a bug if a job calls thjob_exit() or thjob_self() and they thpool_await(), if the jobs are not currently running they are run in the calling thread of execution, this poses problems because thjob_exit and thjob_self rely on thread local data and process specific sigmasks. No solution to this is a great one, either I try to work around this by adding insane complexity, or I could move the waited on job to the front of the queue. This is the best solution most likely. It is not ideal. If users expect to be waiting on specific jobs and also plan on queuing many jobs which take a long time to finish, they should consider setting the thread pool up to use more system threads. It is also possible to use change_num_threads() to increase the number of threads and then try waiting on a thread. This is also not ideal, but I don't have the luxury of kernel space control over processes, increasing system threads seems to be the best, perhaps will consider creating a system thread just to run this, however this is also bad because its expensive and the whole point of a thread pool is to remove that expense. There are not great solutions here, if I want to keep what I think are really cool features of this implementation this is a trade off I suppose. 